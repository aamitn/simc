# Name of the workflow
name: Build , Deploy to GitHub Pages and Publish Electron Binaries

on:
  # Trigger the workflow on pushes to the 'main' branch
  push:
    branches:
      - main # Or your default branch, e.g., 'master'
    tags:
      - 'v*.*.*' # This will trigger on any tag starting with 'v' followed by dot-separated numbers (e.g., v1.0.0, v2.1.3)
      - '*-rc'   # Example: Trigger on release candidates (e.g., 1.0.0-rc)

  # Trigger the workflow on pull requests targeting the 'main' branch
  pull_request:
    branches:
      - main # Or your default branch, e.g., 'master'

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Grant GITHUB_TOKEN the necessary permissions to deploy to GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

env:
  # BUILD_PATH: "." # default value when not using subfolders
   ASTRO_SOURCE: site-source # The directory where the Astro source files are located
   BUILD_OUTPUT: site # The directory where the built site will be outputted for both astro and gradle
   GRADLE_SOURCE: "." # The directory where the SimC source files are located
   ELECTRON_SOURCE: app # The directory where the SimC source files are located

jobs:
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Step 1: Checkout the repository code
      # This action checks out your repository under $GITHUB_WORKSPACE, so your workflow can access it.
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Set up Java Development Kit (JDK) 8
      # This action sets up a Java environment, crucial for Gradle.
      - name: Set up JDK 8
        uses: actions/setup-java@v4
        with:
          java-version: '8' # Use Eclipse Temurin JDK 8/1.8
          distribution: 'temurin' # Recommended distribution for OpenJDK 8
          cache: 'gradle' # Cache Gradle dependencies for faster builds

      # Step 3: Set up Node.js (LTS version)
      # This action sets up a Node.js environment. We'll use the latest LTS.
      - name: Set up Node.js LTS
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*' # Installs the latest LTS Node.js version
          cache: 'npm' # Cache npm dependencies for faster installs
          cache-dependency-path: '${{ env.ASTRO_SOURCE }}/package-lock.json'


      # Step 4: Setup GitHub Pages environment
      # This step configures the GitHub Pages environment and provides outputs needed for Astro build.
      - name: Setup Pages
        id: pages # Assign an ID to this step to reference its outputs
        uses: actions/configure-pages@v5 # Using v5 as seen in the Astro workflow for base_path/origin outputs

      # Step 5: Setup Gradle and Run Gradle tasks
      # This action helps run Gradle commands and can cache Gradle dependencies.
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      # Step 6: Install Astro Node.js dependencies and build the site-source project (Astro build)
      # Assumes your Node.js project (with package.json) is in a directory named 'site-source'
      # within the root of your repository.
      - name: ASTRO-Install Node.js dependencies and build Astro site
        run: |
          echo "Installing npm dependencies in ${{ env.ASTRO_SOURCE }}"
          npm ci
          echo "Building site-source project with Astro"
          # Use npx to run astro command and pass GitHub Pages specific site and base paths
          npx --no-install astro build --site "${{ steps.pages.outputs.origin }}" --base "${{ steps.pages.outputs.base_path }}"
        working-directory: ${{ env.ASTRO_SOURCE }} # Sets the working directory for this step

      # Step 7: Run Gradle build tasks (Simc build)
      # Start build process with gradle
      - name: Build with Gradle
        run: |
          echo "Make gradle wrapper executable..." 
          chmod +x gradlew
          echo "Running Gradle build dry run..."
          gradle build --dry-run 
          echo "Running Gradle compileGwt with verbose output..."
          gradle compileGwt --console verbose --info
          echo "Running Gradle makeSite with verbose output..."
          gradle makeSite --console verbose --info
        working-directory: ${{ env.GRADLE_SOURCE }} # Sets the working directory for this step

      # Step 8: Upload the 'site' directory as a GitHub Pages artifact
      # The 'site' directory is assumed to be generated by 'gradle makeSite' in the root,
      # and should now contain the correctly built Astro assets.
      - name: Upload GitHub Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './${{ env.BUILD_OUTPUT }}' # The path to the directory that will be deployed as GitHub Pages


      # Step 9: Upload the site output for Electron build
      - name: Upload site output for Electron and Pages
        id: upload
        uses: actions/upload-artifact@v4
        with:
          name: site-artifact
          path: ${{ env.BUILD_OUTPUT }}


  # Deploy the uploaded artifact to GitHub Pages
  # This action takes the artifact and deploys it to your GitHub Pages site.
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    needs: build
    runs-on: ubuntu-latest
    name: Deploy
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

        
  # Electron build on Ubuntu
  electron-ubuntu:
    needs: build
    runs-on: ubuntu-latest
    name: Electron Linux Publish (deb,rpm)
    steps:
      # Step 1: Checkout the repository code
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Download shared artifacts
      - name: Download shared build output (Astro + Gradle)
        uses: actions/download-artifact@v4
        with:
          name: site-artifact
          path: ${{ env.BUILD_OUTPUT }}

      # Step 3: setup node     
      - name: Set up Node.js LTS
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*' # Installs the latest LTS Node.js version
          cache: 'npm' # Cache npm dependencies for faster installs
          cache-dependency-path: '${{ env.ELECTRON_SOURCE }}/package-lock.json'

      # Step 4: Install Electron Node.js dependencies and run publish for the 'app' directory (Electron Build)
      # This step assumes there's a Node.js project in the 'app' directory
      # and that 'npm run publish' will output its artifacts to the main build output directory (e.g., './site').
      - name: ELECTRTON-Install Node.js dependencies and publish Electron 'app'
        run: |
          echo "Installing npm dependencies in 'app' directory..."
          npm ci # Use 'ci' for clean installs in CI environments
          echo "Setting Environment Var for auth token..."
          export GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}
          echo "Running 'npm run publish' in 'app' directory..."
          npm run publish
        working-directory: './${{ env.ELECTRON_SOURCE }}' # Sets the working directory for this step to the 'app' folder

  # Electron build on  Windows
  electron-windows:
    needs: build
    runs-on: windows-latest
    name: Electron Windows Publish (exe,msi,appx)
    steps:
      # Step 1: Checkout the repository code
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Download shared artifacts
      - name: Download shared build output (Astro + Gradle)
        uses: actions/download-artifact@v4
        with:
          name: site-artifact
          path: ${{ env.BUILD_OUTPUT }}

      # Step 3: setup node     
      - name: Set up Node.js LTS
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*' # Installs the latest LTS Node.js version
          cache: 'npm' # Cache npm dependencies for faster installs
          cache-dependency-path: '${{ env.ELECTRON_SOURCE }}/package-lock.json'

      # Step 4: Install Electron Node.js dependencies and run publish for the 'app' directory (Electron Build)
      # This step assumes there's a Node.js project in the 'app' directory
      # and that 'npm run publish' will output its artifacts to the main build output directory (e.g., './site').
      - name: ELECTRTON-Install Node.js dependencies and publish Electron 'app'
        run: |
          echo "Installing npm dependencies in 'app' directory..."
          npm ci # Use 'ci' for clean installs in CI environments
          echo "Setting Environment Var for auth token in powershell..."
          $env:GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          echo "Running 'npm run publish' in 'app' directory..."
          npm run publish
        working-directory: './${{ env.ELECTRON_SOURCE }}' # Sets the working directory for this step to the 'app' folder        
  
  
  # Electron build on  MacOS
  electron-macos:
    needs: build
    runs-on: macos-latest
    name: Electron MacOS Publish (dmg,pkg)      
    steps:
      # Step 1: Checkout the repository code
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Download shared artifacts
      - name: Download shared build output (Astro + Gradle)
        uses: actions/download-artifact@v4
        with:
          name: site-artifact
          path: ${{ env.BUILD_OUTPUT }}

      # Step 3: Setup Node.js
      - name: Set up Node.js LTS
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*' # Installs the latest LTS Node.js version
          cache: 'npm' # Cache npm dependencies for faster installs
          cache-dependency-path: '${{ env.ELECTRON_SOURCE }}/package-lock.json'

      # --- NEW STEPS FOR MACOS CODE SIGNING ---
      # Step 4: Create a temporary keychain and import your self-signed .p12 certificate
      - name: Create temporary keychain and import certificate
        env:
          # IMPORTANT: Store your Base64 encoded .p12 and its password as GitHub Secrets
          # Example secrets: MACOS_SELF_SIGNED_P12, MACOS_SELF_SIGNED_P12_PASSWORD
          P12_BASE64: ${{ secrets.MACOS_CERT_P12_BASE64 }} 
          P12_PASSWORD: ${{ secrets.MACOS_CERT_P12_PASSWORD }}
          # Define a temporary keychain name and path for this job
          TEMP_KEYCHAIN_NAME: github-actions-temp-keychain
          TEMP_KEYCHAIN_PATH: ~/Library/Keychains/${{ env.TEMP_KEYCHAIN_NAME }}.keychain
        run: |
          echo "Creating new temporary keychain: ${{ env.TEMP_KEYCHAIN_PATH }}"
          # Create a new temporary keychain with a password
          security create-keychain -p "$P12_PASSWORD" "${{ env.TEMP_KEYCHAIN_PATH }}"
          # Unlock the created keychain
          security unlock-keychain -p "$P12_PASSWORD" "${{ env.TEMP_KEYCHAIN_PATH }}"
          # Set keychain timeout to 1 hour (3600 seconds) and lock it immediately
          security set-keychain-settings -t 3600 -l "${{ env.TEMP_KEYCHAIN_PATH }}"

          echo "Setting temporary keychain as default and adding to search list"
          # Set this new keychain as the default keychain
          security default-keychain -s "${{ env.TEMP_KEYCHAIN_PATH }}"
          # Add it to the keychain search list
          security list-keychains -s "${{ env.TEMP_KEYCHAIN_PATH }}"

          echo "Decoding and importing P12 certificate into keychain"
          # Decode the Base64 P12 content from the secret into a temporary file
          echo "$P12_BASE64" | base64 --decode > cert.p12
          # Import the certificate into the temporary keychain
          # -T flags grant necessary access to signing tools (codesign, security, productbuild, pkgbuild)
          security import cert.p12 -k "${{ env.TEMP_KEYCHAIN_PATH }}" -P "$P12_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -T /usr/bin/productbuild \
            -T /usr/bin/pkgbuild
            # If Electron Forge itself needs direct access to the keychain, uncomment the following:
            # -T /usr/local/bin/electron-forge 

          rm cert.p12 # Remove the temporary .p12 file for security

          echo "Verifying identities in keychain (for debugging purposes):"
          # List identities in the newly created keychain.
          # '|| true' ensures the step doesn't fail if no identity is immediately found,
          # allowing you to see logs for further debugging.
          security find-identity -p codesigning "${{ env.TEMP_KEYCHAIN_PATH }}" || true 

          # Export the temporary keychain name and path so subsequent steps can use them
          echo "TEMP_KEYCHAIN_PATH=${{ env.TEMP_KEYCHAIN_PATH }}" >> "$GITHUB_ENV"
          echo "TEMP_KEYCHAIN_NAME=${{ env.TEMP_KEYCHAIN_NAME }}" >> "$GITHUB_ENV"

      # Step 5: Install Electron Node.js dependencies (moved from Step 4)
      - name: Install Electron Node.js dependencies
        working-directory: './${{ env.ELECTRON_SOURCE }}'
        run: |
          echo "Installing npm dependencies in 'app' directory..."
          npm ci # Use 'ci' for clean installs in CI environments

      # Step 6: Run Electron 'publish' with custom keychain configuration (moved from Step 4)
      - name: ELECTRON-Publish Electron 'app' with signing
        working-directory: './${{ env.ELECTRON_SOURCE }}'
        env:
          # Set GITHUB_TOKEN if your 'npm run publish' command interacts with GitHub (e.g., for releases)
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # These environment variables are crucial for Electron Forge/electron-osx-sign
          # to find and use your certificate from the custom keychain.
          # CSC_KEYCHAIN should point to the temporary keychain name or path.
          CSC_KEYCHAIN: ${{ env.TEMP_KEYCHAIN_NAME }} # Using the name of the keychain
          CSC_P12_PASSWORD: ${{ secrets.MACOS_CERT_P12_PASSWORD }}
          # Setting this to 'false' forces the signing process to rely on explicitly
          # provided keychain and password, rather than auto-discovery.
          CSC_IDENTITY_AUTO_DISCOVERY: false 
          # If your self-signed certificate has a specific common name (e.g., "My Self-Signed Dev ID"),
          # uncomment and set these to match the exact identity name as seen in 'security find-identity'.
          # This explicitly tells the signing tool which identity to use.
          # CSC_NAME: "Your Self-Signed Identity Name" # For .app bundle signing
          # CSC_INSTALLER_NAME: "Your Self-Signed Identity Name" # For .pkg installer signing
        run: |
          echo "Running 'npm run publish' in 'app' directory..."
          npm run publish
